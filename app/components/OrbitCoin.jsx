/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { useEnvironment, useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import gsap from "gsap";

const OrbitCoin = ({ active, ...props }) => {
  const { nodes, materials } = useGLTF("./models/bitcoin.glb");

  const coinRef = useRef();
  const tl = useRef();
  const fadeRef = useRef(0);

  const scroll = useScroll();
  const env = useEnvironment({ files: "./textures/gold.jpg" });

  /* ---------------- Responsive ---------------- */

  let radius = 4.5;
  let responsiveScale = 2;

  if (typeof window !== "undefined") {
    if (window.innerWidth < 480) {
      radius = 2.3;
      responsiveScale = 1.5;
    } else if (window.innerWidth < 769) {
      radius = 3.5;
    }
  }

  /* ---------------- Material Setup ---------------- */

  useEffect(() => {
    if (!coinRef.current) return;

    const mat = coinRef.current.material;
    mat.envMap = env;
    mat.transparent = true;
    mat.opacity = 1;
  }, [env]);

  /* ---------------- Orbit Animation ---------------- */

  useEffect(() => {
    if (!coinRef.current) return;

    const coin = coinRef.current;

    if (tl.current) tl.current.kill();

    const state = { angle: 0 };

    tl.current = gsap.timeline({ repeat: -1 });

    tl.current.to(state, {
      angle: Math.PI * 2,
      duration: 8,
      ease: "none",
      onUpdate: () => {
        coin.position.x = radius * Math.sin(state.angle);
        coin.position.z = radius * Math.cos(state.angle);
        coin.position.y = 0.8 * Math.sin(state.angle * 2);

        coin.rotation.y -= 0.03;
        coin.rotation.x -= 0.02;
        coin.rotation.z -= 0.015;
      },
    });

    return () => tl.current?.kill();
  }, []);

  /* ---------------- Scroll Logic ---------------- */

  useFrame(() => {
    if (!coinRef.current) return;

    /* ---- Fade after 50% scroll ---- */
    const targetFade = THREE.MathUtils.clamp(
      (scroll.offset - 0.2) * 5,
      0,
      1
    );

    fadeRef.current = THREE.MathUtils.lerp(
      fadeRef.current,
      targetFade,
      0.08
    );

    const opacity = 1 - fadeRef.current;
    coinRef.current.material.opacity = opacity;
    coinRef.current.visible = opacity > 0.01;

    /* ---- Stop orbit after 20% scroll ---- */
    if (scroll.offset > 0.2 || active) {
      tl.current?.pause();
    } else {
      tl.current?.resume();
    }
  });

  /* ---------------- Render ---------------- */

  return (
    <group {...props} dispose={null} scale={responsiveScale}>
      <mesh
        ref={coinRef}
        geometry={nodes.Cylinder001.geometry}
        material={materials["Gold.004"]}
        rotation={[Math.PI * 1.5, 0, Math.PI]}
        scale={[0.388, 0.039, 0.388]}
      />
    </group>
  );
};

useGLTF.preload("./models/bitcoin.glb");

export default OrbitCoin;
